<!DOCTYPE html>

<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <meta name="description" content="Creative technologist three.js 3D programmer. Animation lover.">
    <meta name="author" content="@la_loleiro">
    <title>@la_loleiro</title>
    <link rel="stylesheet" href="css/estilos.css" type="text/css" >
    <link rel="stylesheet" href="css/banana.css" media="screen">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <link rel="icon" href="favicon.ico">
    <title>HOME</title>
    <style>
      #c {
       width: 100%;
       height: 85vh;
       display: block;
      }
    </style>
  </head>

  <body>
  <!--  <div id="loader" class="loader"></div>
    <div id="content" class="hidden">  -->
    <header>
        <div class="logo">
          <div id="gifs-rows">
            <img src="img/feetClap/feetClap_2.png" alt="It's a banana!">
          </div>
        </div>

        <button class="iconoHamburguesa" onclick="mostrarOcultarMenu();">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
              <path fill-rule="evenodd" d="M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z"/>
            </svg>
        </button>
        <nav class="menuPrincipal">
            <ul role="navigation">
                <li><a href="visualunderstanding.html">Visual Understanding</a></li>
                <li><a href="works.html">Works</a></li>
            </ul>
        </nav>
    </header>
      <main role="main">
         <canvas id="c"></canvas>
      </main>
  </body>

  <script type="importmap">
      {
        "imports": {
          "three": "./three/build/three.module.js",
          "three/addons/": "./three/examples/jsm/"
        }
      }
  </script>
  <script type="module">
      /* to avoid multiple imports, use the above importmap: {...} from 'three'; */
      import * as THREE from 'three';
      import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

      function main(){
        //RENDERER
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
        renderer.shadowMap.enabled = true;

        //CAMERA
        const fov = 45;
        const aspect = 2;  // the canvas default
        const near = 1;
        const far = 50;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(0, 5, 20);

        //CONTROLS
        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 5, 0);
        controls.shadowsCast = 1;
        controls.update();

        //SCENE
        const scene = new THREE.Scene();
        scene.background = new THREE.Color( 0x99cccc );

        // { //FOG
        //   const color = 0xFFFFFF;  // white
        //   const near = 100;
        //   const far = 100;
        //   scene.fog = new THREE.Fog(color, near, far);
        // }

        function makeTetaInstance(x,y,z, colorMama, colorPezon) {
            const teta = new THREE.Object3D();
            scene.add(teta);

            const sphereRadius = 2.8;
            const sphereWidthDivisions = 32;
            const sphereHeightDivisions = 16;
            const sphereGeo = new THREE.SphereGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
            const sphereMat = new THREE.MeshPhongMaterial({color: colorMama});
            const mesh = new THREE.Mesh(sphereGeo, sphereMat);
            teta.add(mesh);

            const pezon = new THREE.Object3D();
            //pezon.position.set(sphereRadius/2, sphereRadius/2, sphereRadius);
            teta.add(pezon);
            const radiusTop =  0.5;
            const radiusBottom =  1;
            const height =  1;
            const radialSegments = 32;
            const pezonMat = new THREE.MeshPhongMaterial({color: colorPezon});
            const pezonGeom = new THREE.CylinderGeometry( radiusTop, radiusBottom, height, radialSegments );
            const pezonMesh = new THREE.Mesh(pezonGeom, pezonMat);
            pezonMesh.rotation.set(0 ,-1.5708, -1.5708);
            pezonMesh.position.set(0, 0, 3);
            pezon.add(pezonMesh);

            teta.position.set(x,y,z);
            return teta;
          }

        const tetas = [
          makeTetaInstance(-8, 2, 3, 0x1a0d00, 0x4f2903 ),
          makeTetaInstance(-5, 9, 0, '#CA9', 0xbb7458),
          makeTetaInstance(3, 5, -4, 0xe0c4ad, 0xAC7B57),
          makeTetaInstance(12, 0, -8, 0xf3e4b2,  0xbb7458),
          makeTetaInstance(18, 10, -8, 0x93775b, 0x815e3d),
        ];


        const nubes = [];
        {  //NUBES

          const loader = new GLTFLoader();
          const srcNubes = ['models/gltf/nube.glb', 'models/gltf/nube_s.glb'];

          const nubePositions = [
              [srcNubes[1], 0, 3, 4],
              [srcNubes[1], -10, 10, 5],
              [srcNubes[1], -5, 12, -14],
              [srcNubes[0], 3, 9, -9],
              [srcNubes[1], 8, 6, 1],
              [srcNubes[0], -8, 5, 4],
            ];

          nubePositions.forEach(([src, x, y, z], index) => {
            loadNube(src, x, y, z); // Stagger fade-in by 0.3s per cloud
          });

          /*const numNubes = 5;
          for (let i = 0; i < numNubes; ++i) {
            loadNube(srcNubes[1], 0, numNubes-2, numNubes-1),
            loadNube(srcNubes[1], -numNubes-5, 10, numNubes),
            loadNube(srcNubes[1], -numNubes, 12, -numNubes-9),
            loadNube(srcNubes[0], 3, 9, -numNubes-4),
            loadNube(srcNubes[1], 8, 6, 1),
            loadNube(srcNubes[0], -8, numNubes, 4)
          }
      */
           function loadNube(src, x, y , z){
              loader.load( src , function ( gltf ) {
                scene.add( gltf.scene );
                gltf.scene.children.forEach((obj) => {
                 // obj.material.transparent = true;
                 // obj.material.opacity = 0.5;
                  obj.position.x = x;
                  obj.position.y = y;
                  obj.position.z = z;
                });
                nubes.push( gltf.scene);
              }, undefined, function ( error ) {
                console.error( error );
              });
          }
        } //fin NUBES

    /*   { // HEMISPHERE LIGHT
          const skyColor = 0xB1E1FF;  // light blue
          const groundColor = 0xB97A20;  // brownish orange
          const intensity = 2;
          const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
          scene.add(light);
        }
*/

        {//AMBIENT LIGHT
          const ambient = new THREE.AmbientLight( 0xffffff );
          scene.add( ambient );
        }

        { //DIRECTIONAL LIGHT
          const color = 0xffffff;
          const intensity = 3;
          const light = new THREE.DirectionalLight(color, intensity);
          //light.castShadow = true;
          light.position.set(0, 5, 5);
          light.target.position.set(-5, 0, 0);
          scene.add(light);
          scene.add(light.target);
        }

        function resizeRendererToDisplaySize(renderer) { //Devuelve true si hay que cambiar la resolución del canvas (cambiój el tamaño de la ventana)
          const canvas = renderer.domElement;
          const pixelRatio = window.devicePixelRatio;
          const width = canvas.clientWidth * pixelRatio | 0 ;
          const height = canvas.clientHeight * pixelRatio | 0 ;
          const needResize = canvas.width !== width || canvas.height !== height;
          if (needResize) {
            renderer.setSize(width, height, false);
          }
          return needResize;
        }

          let acceleration = 0.5;
          let bounce_distance = 2;
          let bottom_position_y = -2;
          let time_step = 0.01;
          // time_counter is calculated to be the time the ball just reached the top position
          // this is simply calculated with the s = (1/2)gt*t formula, which is the case when ball is dropped from the top position
          let time_counter = Math.sqrt(bounce_distance * 2 / acceleration);
          let initial_speed = acceleration * time_counter;

          function render(time) {
            //time *= 0.001;  // convert time to seconds
            time = 0.005;  // convert time to seconds
            //console.log(nubes);
            nubes.forEach((obj) => {
              obj.position.x += time;
            });

            if (resizeRendererToDisplaySize(renderer)) {
              const canvas = renderer.domElement;
              camera.aspect = canvas.clientWidth / canvas.clientHeight;
              camera.updateProjectionMatrix();
            }
            renderer.render(scene, camera);
            requestAnimationFrame(render);
          }
          requestAnimationFrame(render);
}//fin MAIN



main();

</script>
<script src="js/jquery.js"></script>
<script src="js/main.js"></script>

</html>